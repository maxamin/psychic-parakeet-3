//
//  CVulnerability.m
//  XSecurity
//
//  Created by Pedraita, Raymund on 12/17/13.
//  Copyright (c) 2014 XSecurity Project. All rights reserved.
//

#import "CVulnerability.h"
#import <Cocoa/Cocoa.h>
#import "CLog.h"
#import "XSecDefs.h"
#import "CTargetCode.h"
#import "CResult.h"

//#import "NSRegularExpression.h"

//BOOL bRet = FALSE ;
//
//do
//{
//} while ( _PASSING_ ) ;
//
//return bRet ;

//do
//{
//    self = [super init] ;
//
//    if ( !self )
//    {
//        break ;
//    }
//} while ( _PASSING_ ) ;
//
//return self ;


//////////////////////////////////////////////////////////////////////////////////////

@implementation CVulnerability
// This should be an array of subclasses of CInstance
@synthesize m_aobjInstances ;

- (id) init
{
    do
    {
        self = [super init] ;
        
        if ( !self )
        {
            break ;
        }
        
        m_szName        = nil ;
        m_eSeverity     = E_SEVERITY_INVALID ;
        m_bStripComment = FALSE  ;
        m_szDescription = nil ;
        m_aszReferences = nil ;
        m_objCategory   = nil ;
        
        m_aRegExps      = nil ;
        m_aobjInstances = nil ;
        
    } while ( _PASSING_ ) ;
    
    return self ;
}


- (void) dealloc
{
    [m_szName        release], m_szName        = nil ;
     m_eSeverity     = E_SEVERITY_INVALID ;
     m_bStripComment = FALSE ;
    [m_szDescription release], m_szDescription = nil ;
    [m_aszReferences release], m_aszReferences = nil ;
    [m_objCategory release]  , m_objCategory   = nil ;
    
    [m_aRegExps      release], m_aRegExps      = nil ;
    [m_aobjInstances release], m_aobjInstances = nil ;

    [super dealloc] ;
}


- (id) initWithName: (NSString     *) szName
      eSeverity    : (E_SEVERITY    ) eSeverity
      bStripComment: (BOOL          ) bStripComment
      szDescription: (NSString     *) szDescription
      aszReferences: (NSArray      *) aszReferences
// Every subclass should have their own interpretation of instances
      dicInstances : (NSDictionary *)  dicInstances
      objCategory  : (CVulnCategory *) objCategory ;
{
    do
    {
        self = [super init] ;
        
        if ( !self )
        {
            break ;
        }
        
        m_szName         = szName        , [m_szName retain] ;
        m_eSeverity      = eSeverity ;
        m_bStripComment  = bStripComment ;
        m_szDescription  = szDescription , [m_szDescription retain] ;
        m_aszReferences  = aszReferences , [m_aszReferences retain] ;
        m_objCategory    = objCategory   , [m_objCategory retain] ;
        
        m_aRegExps       = nil ;
        m_aobjInstances  = [self initInstancesFromDictionary: dicInstances ], [m_aobjInstances retain] ;
        
        
        if ( m_eSeverity >= E_SEVERITY_MAX )
        {
            m_eSeverity = E_SEVERITY_INVALID ;
        }
        
    } while ( _PASSING_ ) ;
    
    return self ;
}

- (NSString *) getName
{
    return m_szName ;
}

- (E_SEVERITY) getSeverity
{
    return m_eSeverity ;
}

- (BOOL) willStripComment
{
    return m_bStripComment ;
}

- (NSString *) getDescription
{
    return m_szDescription ;
}

- (NSArray *) getRegExpressions
{
    return m_aRegExps ;
}

- (CVulnCategory *) getCategory
{
    return m_objCategory ;
}

// Potected methods
// Found one trick and it work, extend this through category
- (void) setRegExpressions: (NSArray *) aRegExps
{
    if ( m_aRegExps )
    {
        [m_aRegExps release] ; // Release the old value
    }
    
    m_aRegExps = aRegExps ;
    [m_aRegExps retain] ;
  
//    NSUInteger iCount = [m_aRegExps retainCount] ;
//    [Log xlogv: @"m_aRegExps count %@", iCount] ;
}

//NOTE: This should be generic, unlikely to be overidden but can be if necessary
//      For the meantime were are not interested in capture groups.

// Returns a two dimensional, array of array of CResult objects
// The outer array represents each expression/pattern
// The inner array represents each match for that particular expression
// Thus expression X matches
- (NSArray *) detect: (CTargetCode *)objTarget bCommentRemoved: (BOOL) bCommentRemoved
{
    NSArray *aaRet = nil ;
    [CLog xlogv:@"Detecting class name: %@  \t\t vuln: %@ ...", [self className], [self getName] ] ;
    
    NSMutableArray *aaAllResults = [ [[NSMutableArray alloc] init] autorelease ] ;
    
    do
    {
        if ( !aaAllResults || !objTarget )
        {
            break ;
        }
        
        // This is being managed internally, not allocated everytime so no need to retain or release it
        NSArray *aRegExps = [self generateExpressions] ;
        
        if ( !aRegExps )
        {
            break ;
        }

        // This assumes that objTarget is not that big to make noticeable performance degredation
        if ( [self willStripComment] && !bCommentRemoved )
        {
            // Creates a copy of itself and be that object instead
            objTarget = [objTarget copy] ;
            
            // arbitrary character but may change if necessary
            [objTarget maskCommentWith: '#' ] ;
        }
        
        NSString *szData = [objTarget getDataAsString] ;
        
        if ( ![aRegExps count] )
        {
            break ;
        }
        
        for ( NSRegularExpression *regExpr in aRegExps )
        {
            NSMutableArray *aResultsForExp = [ [[NSMutableArray alloc] init] autorelease ] ;
            
            // Out of memory?
            if ( !aResultsForExp )
            {
                break ;
            }
            
            //TODO: Consider NSMatchingOptions should differ per vulnerability as the need rises 
            NSArray *aMatches = [ regExpr matchesInString: szData options: NSMatchingWithTransparentBounds range: NSMakeRange(0, [szData length] ) ] ;
            
            for ( NSTextCheckingResult *txtResult in aMatches )
            {
                CResult *objResult = nil ;
                
                // Lets include the negatives, who knows if it will give out one
                if ( ([txtResult rangeAtIndex: 1].length <= 0) )
                {
//                    continue ;
                }
                
                @try
                {
                    objResult = [ [CResult alloc] initWithData: [txtResult rangeAtIndex: 1] objTarget: objTarget objVuln: self szExpression: [regExpr pattern] ] ;
                }
                @catch (NSException *objExp)
                {
                    
                    [CLog xlogv: @"Exception, one possible problem is rangeAtIndex failed details: %@", [objExp reason]] ;
                }
                
                // Error? not consistent from above check
                if ( !objResult )
                {
                    continue ;
                }
                
                [aResultsForExp addObject: objResult] ;
                [objResult release] ;
            }
            
            if ( ![aResultsForExp count] )
            {
                continue ;
            }
            
            [ aaAllResults addObject: [NSArray arrayWithArray: aResultsForExp] ] ;
        }
        
        if ( ![aaAllResults count] )
        {
            break ;
        }
        
        aaRet = [NSArray arrayWithArray: aaAllResults] ;
        
    } while ( _PASSING_ ) ;
 
    [CLog xlog:@"Done!"] ;
    
    return aaRet ;
}

//Convert string patterns to regular expression objects
- (NSArray *) toExpressions:(NSMutableArray *) aszPatterns
{
    return [self toExpressions: aszPatterns option: 0] ;
}

//Convert string patterns to regular expression objects
- (NSArray *) toExpressions:(NSMutableArray *) aszPatterns option: (NSRegularExpressionOptions)option
{
    NSMutableArray *aRetRegs = nil ;
    
    do
    {
        NSMutableArray *aWorkRegs = [ [[NSMutableArray alloc] init] autorelease ] ;
        
        if ( !aWorkRegs )
        {
            break ;
        }
        
        for ( NSString *szPattern in aszPatterns )
        {
            NSError *err = nil ;
            
            NSRegularExpression *regEx = [ NSRegularExpression regularExpressionWithPattern: szPattern options: (NSRegularExpressionOptions) option error: &err ] ;
            
            if ( !regEx )
            {
                continue ;
            }
            
            [aWorkRegs addObject: regEx] ;
        }
        
        if ( ![aWorkRegs count] )
        {
            break ;
        }
        
        aRetRegs = aWorkRegs ;
        
    } while ( _PASSING_ ) ;
    
    return aRetRegs ;
}


@end // CVulnerability

