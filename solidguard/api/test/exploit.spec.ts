import { TestingModule } from '@nestjs/testing';
import { Exploit, Role } from '@prisma/client';
import { assert } from 'console';
import { UserService } from '../src/user/user.service';
import { CreateExploitDto } from '../src/exploit/dto';
import { ExploitService } from '../src/exploit/exploit.service';
import { clearDB, expectAnyAsyncError, getModuleRef } from './utils';

describe('ExploitService', () => {
  let exploitService: ExploitService;
  let moduleRef: TestingModule;
  const exploitDtos: CreateExploitDto[] = [];
  for (let i = 0; i < 13; i++) {
    const letter = String.fromCharCode(97 + i);
    const exploitName = 'Open' + letter;
    const exploitDto: CreateExploitDto = {
      name: exploitName,
      authorUserId: 'generate-via-mongodb',
      description: 'Lorem ipsum',
      targetAddr: '0x51B9638447d87d69933C9888B36aDA95Ed7549c0',
      targetNames: ['SolidGuardManager'],
    };
    exploitDtos.push(exploitDto);
  }
  const searchExploitRequestDtoPage1 = {
    pageNo: 1,
    name: 'Op',
  };
  let exploit: Exploit;
  beforeEach(async () => {
    moduleRef = await getModuleRef();
    exploitService = moduleRef.get<ExploitService>(ExploitService);
    await clearDB();

    // update all exploitDtos to use user.id
    const userService = moduleRef.get<UserService>(UserService);
    const user = await userService.createAccount({
      name: 'x',
      password: 'y',
      role: Role.USER,
    });
    for (let i = 0; i < 13; i++) {
      exploitDtos[i] = { ...exploitDtos[i], authorUserId: user.id };
    }

    exploit = await exploitService.createExploit(exploitDtos[0]);
  });

  describe('createExploit', () => {
    it('Create a new Exploit', async () => {
      expect(exploit.name).toBe(exploitDtos[0].name);
      expect(exploit.authorUserId).toBe(exploitDtos[0].authorUserId);
      expect(exploit.description).toBe(exploitDtos[0].description);
    });

    it('Throw error when trying to create a repeat Exploit with exsiting name', async () => {
      await expectAnyAsyncError(exploitService.createExploit(exploitDtos[0]));
    });
  });

  describe('getExploit', () => {
    beforeAll(async () => {
      moduleRef = await getModuleRef();
      exploitService = moduleRef.get<ExploitService>(ExploitService);
      await clearDB();
    });

    it('Get an Exploit by id', async () => {
      const getExploit = await exploitService.getExploit(exploit.id);
      expect(exploit).toEqual(getExploit);
    });
  });

  describe('getUserExploit', () => {
    beforeAll(async () => {
      moduleRef = await getModuleRef();
      exploitService = moduleRef.get<ExploitService>(ExploitService);
      await clearDB();
    });

    it('Get Exploits by user id', async () => {
      const getExploit = await exploitService.getUserExploit(
        exploit.authorUserId,
        1
      );
      expect(exploit).toEqual(getExploit[0]);
      await clearDB();
    });

    it('get multiple exploits', async () => {
      const result = [];
      for (let i = 1; i < 11; i++) {
        const temp = await exploitService.createExploit(exploitDtos[i]);
        result.push(temp);
      }
      result.reverse();

      const getExploit = await exploitService.getUserExploit(
        result[0].authorUserId,
        1
      );
      expect(getExploit).toEqual(result);
      expect(getExploit.length).toEqual(10);
    });
  });

  describe('searchExploitByName', () => {
    it('Search Exploit by name in empty db', async () => {
      await clearDB();
      const dneExploits = await exploitService.searchExploitByName(
        searchExploitRequestDtoPage1
      );
      expect(dneExploits).toEqual([]);
    });
    it('Search Exploits by name on first page (pageNo=1)', async () => {
      const result = [];
      result.push(exploit);
      const pageNo = 1;
      assert(pageNo > 0);
      const exploitsOp = await exploitService.searchExploitByName(
        searchExploitRequestDtoPage1
      );
      expect(exploitsOp).toEqual(result);
    });
    it('Search Exploits by name is case sensitive', async () => {
      const searchExploitRequestDtoCaseSens = {
        pageNo: 1,
        name: 'o',
      };
      const result = [];
      const pageNo = 1;
      assert(pageNo > 0);
      const exploitsOp = await exploitService.searchExploitByName(
        searchExploitRequestDtoCaseSens
      );
      expect(exploitsOp).toEqual(result);
    });
    it('Search Exploit by non-exist name', async () => {
      const searchExploitRequestDtoDNEName = {
        pageNo: 1,
        name: 'hi',
      };
      const dneExploits = await exploitService.searchExploitByName(
        searchExploitRequestDtoDNEName
      );
      expect(dneExploits).toEqual([]);
    });
    it('Search Exploit by name on second page (pageNo=2)', async () => {
      const result = [];
      for (let i = 1; i < 12; i++) {
        await exploitService.createExploit(exploitDtos[i]);
      }
      result.push(await exploitService.createExploit(exploitDtos[12]));
      const searchExploitRequestDtoPage2 = {
        pageNo: 2,
        name: 'Op',
      };
      const exploitsOp = await exploitService.searchExploitByName(
        searchExploitRequestDtoPage2
      );
      expect(exploitsOp).toEqual(result);
    });
  });

  describe('verifyExploit', () => {
    it('Check verify of Exploit is false by default', async () => {
      expect(exploit.verified).toBe(false);
    });
    it('Update a Exploit to be Verified by id', async () => {
      await exploitService.verifyExploit(exploit.id);
      const getExploit = await exploitService.getExploit(exploit.id);
      expect(getExploit.verified).toBe(true);
    });
  });
});
