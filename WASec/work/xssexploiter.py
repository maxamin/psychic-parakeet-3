'''
    WASec â€“ a software that performs automated tests on websites and scan them for SQL Injection and Cross-site Scripting Vulnerabilites.
    Copyright (c) 2018, Inass Husien.

    WASec is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation, either version 2 of the License or (at your option) any later version.

    This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied
    warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

    You should have received a copy of the GNU General Public License along with this program.
    If not, see <http://www.gnu.org/licenses/>

    You can contact us at e.ismail@it.misuratau.edu.ly
'''
import io
from PyQt5 import QtWidgets
from beyondlogin import BeyondLogin
from formhandler import FormHandler
from urllib import parse
from time import sleep
from PyQt5.QtCore import QObject, pyqtSignal
from robobrowser import browser  # Helps generating requests for webpages
from requests import exceptions
from datetime import datetime, timedelta


class XSSExploiter(QObject):
    current = pyqtSignal(str)
    tested = pyqtSignal(int)
    update_tsp = pyqtSignal(int)
    finish = pyqtSignal(dict)

    def __init__(self, info, bases, instance, parent=None):
        super(XSSExploiter, self).__init__(parent)
        self._pages_to_exploit = info['links']
        self.exploited = {}  # filled like this: [[index, url, type, successful_payload]]
        self.count = 0
        self.total = info['total_crawled']
        self.window = instance
        self.info = bases
        if self.info['logged_in']:
            self._logged_in = False
        else:
            self._logged_in = True
        self._dynamic_urls = info['dynamic']
        self._elapsed = 0
        self.delay = 15
        self._requests = 0
        self.forms = []
        self._browser = browser.RoboBrowser(parser="html.parser", user_agent="WASecBot")
        self._browser.session.verify = False
        self.faults = []
        self.current.connect(self.window.lbltargetxss.setText)
        self.tested.connect(self._show_tested)
        self.update_tsp.connect(self.window.pbxsstotal.setValue)
        self.finish.connect(self.window.after_xss)
        self.tested.emit(0)
        self.window.btnxsscancel.clicked.connect(self.pause)
        self.finished = False
        self.running = True

    def _compute_crawl_delay(self):
        self._requests += 1
        if self._requests <= 10:
            self._elapsed += self._browser.response.elapsed.total_seconds()
            delay = self._elapsed / self._requests
            self.delay = delay * 200
            if self.delay >= 180:
                self.delay = 15
        else:
            self._requests = 1
            self._elapsed = self._browser.response.elapsed.total_seconds()
            self.delay = self._elapsed * 200

    def _opener(self, url):
        retry = 0
        while True:
            try:
                self._browser.open(url)
                break
            except exceptions.ConnectionError as ce:
                sleep(self.delay * retry)
                if retry == 10:
                    return False
                else:
                    retry += 1
        return True

    def pause(self):
        self.running = False
        choice = QtWidgets.QMessageBox.question(self.window, "Cancel Testing!",
                                                "WASec is not finished yet, are you sure you want to stop testing?",
                                                QtWidgets.QMessageBox.Cancel | QtWidgets.QMessageBox.Yes)
        if choice == QtWidgets.QMessageBox.Yes:
            self.finished = True
            self.run()
        else:
            self.running = True

    def _show_current(self, url):
        self.window.lbltargetxss.setText(url)

    def _show_tested(self, no):
        self.window.lblxsstot.setText(str(no) + " vulnerabilities")

    def _update_total(self, value):
        self.window.pbxsstotal.setValue(value)

    def _login(self):
        if self.info['logged_in']:
            handel = BeyondLogin(self._browser)
            self._logged_in = handel.get_login_info(self.info)
        else:
            self._logged_in = True

    def _is_listed(self, url):
        for index in self.exploited:
            if self.exploited[index]['url'] == url:
                return True
        return False

    def _is_form_tested(self, test_form, url):
        found = False
        for form in self.forms:
            if form[0] != url and form[1] == test_form.parsed:
                found = True
                break
        if not found:
            self.forms.append([url, test_form.parsed])
        return found

    def _reflected_get(self, page_link):
        self._browser.open(page_link)
        self._compute_crawl_delay()
        original_page = self._browser.parsed

        attacks_file = io.open("payloads/xss-reflected.txt", "r")
        parsed_url = parse.urlparse(page_link)
        query_params = parsed_url.query.split("&")

        for payload in attacks_file:
            new_query = '&'.join(["{}{}".format(param, payload) for param in query_params])
            #  replace old query values with injection values
            parsed_url = parsed_url._replace(query=new_query)
            #  add new generated url to list of injected urls
            injected = parse.urlunparse(parsed_url)
            self.window.lblxsstot.setText("Pausing for " + str(self.delay) + " seconds...")
            sleep(self.delay)
            self.tested.emit(self.count)
            self._opener(injected)
            self._compute_crawl_delay()
            if '200' in str(self._browser.response):
                response_page = self._browser.parsed
                exploited = str(response_page).find(payload) != -1
                if exploited and (original_page != response_page) and (not self._is_listed(page_link)):
                    self.exploited[self.count] = {'url': page_link, 'type': "reflected-get", 'payload': payload}
                    self.count += 1
                    return True
        return False
    
    def _handel_dynamics(self, url):
        result = self._reflected_get(url)
        if result:
            return True
        else:
            return False

    def _reflected_post(self, form, fields, page_link):
        attacks_file = io.open("xss-reflected.txt", "r")
        for payload in attacks_file:
            page = self._browser.parsed
            for attack_field in fields.attack_fields:
                form[attack_field].value = payload

            for box_name in fields.checkboxes:
                # tick checkboxes by assigning their values to them
                form[box_name].value = fields.checkboxes.get(box_name)
                # e.g. <input type='checkbox' name='mycheck' value='ticked'>
                ## fields.checkboxs.get(box_name) ===> ['ticked']
                ## form['mycheck'].value = ['ticked']
                # now, box is ticked

            for radio_name in fields.radios:
                form[radio_name].value = fields.radios.get(radio_name)
                # same as in checkboxes
            #TODO
            #for select in fields.selects:
             #   form[select].value = fields.selects.get(select)

            for field in fields.other_fields:
                if 'textarea' in field:
                    name = fields.other_fields[field]['name']
                    form[name] = "some text"
                elif 'email' in field:
                    name = fields.other_fields[field]['name']
                    form[name] = "soso5220@gmail.com"
                elif field == 'csrf-token':
                    name = fields.other_fields[field]['name']
                    value = fields.other_fields[field]['value']
                    form[name].value = value

            for submit in fields.submit_buttons:  # in case of multiple submits
                if submit != 'NA' and submit.name not in form.submit_fields.keys():
                    form.add_field(submit)

                retry = 0
                while True:
                    try:
                        if submit == 'NA':
                            self._browser.submit_form(form)
                        else:
                            self._browser.submit_form(form, submit=submit)
                        self._compute_crawl_delay()
                        break
                    except exceptions.ConnectionError as ce:
                        self.window.lblxsstot.setText("Pausing for " + str(str(round(self.delay,2))) + " seconds...");
                        sleep(self.delay * retry)
                        self.tested.emit(self.count)
                        if retry == 10:
                            return False
                        else:
                            retry += 1
                # response_url = str(self._browser.url)
                response_page = self._browser.parsed
                exploited = str(response_page).find(payload) != -1
                if exploited and (page != response_page) and (not self._is_listed(page_link)):
                    self.exploited[self.count] = {'url': page_link, 'type': "reflected-post", 'payload': payload}
                    self.count += 1
                    return True
                self.window.lblxsstot.setText("Pausing for " + str(self.delay) + " seconds...")
                sleep(self.delay)
                self.tested.emit(self.count)
        return False

    def _handle_forms(self, page_link):
        self.window.lblxsstot.setText("Pausing for " + str(self.delay) + " seconds...")
        sleep(self.delay)
        self.tested.emit(self.count)
        self._opener(page_link)
        self._compute_crawl_delay()
        forms = self._browser.get_forms()
        for form in forms:
            if not self._is_form_tested(form, page_link):
                fields = FormHandler(self._browser)  # type: FormHandler
                successful = fields.parser(form)
                if successful:
                    # result = True
                    result = self._reflected_post(form, fields, page_link)
                    if result:
                        return
                else:
                    self.faults.append({'url': page_link, 'fault': fields.fault_type['fault']})
            else:
                continue

    def run(self):
        start = datetime.now().time()
        i = 0
        while not self.finished:
            if self.running:
                for index in self._pages_to_exploit:
                    if self._pages_to_exploit[index]['from'] == self.info['login_url'] and not self._logged_in:
                        self._login()
                    for link in self._pages_to_exploit[index]['url'].keys():
                        self.current.emit(link)
                        self._handle_forms(link)
                        found = False
                        if link in self._dynamic_urls:
                            for indexx in self.exploited:
                                if link == self.exploited[indexx]['url']:
                                    found = True
                                    break
                            if found:
                                self._dynamic_urls.remove(link)
                                i += 1
                                self.update_tsp.emit(i)
                                self.tested.emit(self.count)
                                break
                        else:
                            i += 1
                            self.update_tsp.emit(i)
                            self.tested.emit(self.count)
                for url in self._dynamic_urls:
                    self.current.emit(url)
                    self._handel_dynamics(url)
                    i += 1
                    self.update_tsp.emit(i)
                    self.tested.emit(self.count)
                self.finished = True
        self.finish.emit(self._wrap_up(start))

    def _calc_time(self, start):
        finish = datetime.now().time()
        delta1 = timedelta(seconds=start.second, microseconds=start.microsecond,
                           minutes=start.minute, hours=start.hour)
        delta2 = timedelta(seconds=finish.second, microseconds=finish.microsecond,
                           minutes=finish.minute, hours=finish.hour)
        taken = delta2 - delta1
        seconds = round(taken.total_seconds())
        if seconds >= 3600:
            hours = round(seconds / 3600)
            minutes = (round((seconds / 3600) / 60))
            elapsed = str(hours) + ':' + str(minutes) + ' hrs'
        elif seconds >= 60:
            minutes = round(seconds / 60)
            seconds = round(seconds % 60)
            elapsed = str(str(minutes) + '.' + str(seconds) + ' mins')
        else:
            elapsed = str(seconds) + ' secs'
        return elapsed

    def _wrap_up(self, start):
        wrap = {
            'exploited': self.exploited,
            'count': self.count,
            'faults': self.faults,
            'running': self.running,
            'time': self._calc_time(start)
        }
        return wrap
