/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

package bugfind.xxe;

import bugfind.main.OptionsParser;
import bugfind.sootadapters.CallGraphObject;
import bugfind.sootadapters.CallSite;
import bugfind.sootadapters.MethodAnalysis;
import bugfind.sootadapters.MethodDefinition;
import bugfind.sootadapters.SimpleIntraDataFlowAnalysis;
import bugfind.sootadapters.Variable;
import bugfind.utils.misc.XMLUtils;
import java.io.File;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.xml.bind.JAXBException;
import javax.xml.stream.XMLStreamException;
import soot.Body;
import soot.Local;
import soot.Scene;
import soot.SootClass;
import soot.SootMethod;
import soot.Unit;
import soot.Value;
import soot.ValueBox;
import soot.jimple.Stmt;
import soot.jimple.internal.JReturnStmt;
import soot.jimple.internal.JimpleLocal;
import soot.jimple.toolkits.callgraph.CallGraph;
import soot.toolkits.graph.ExceptionalUnitGraph;

/**
 *
 * @author Mikosh
 */
public class XXEVulnerabilityDetector {
    private static final Logger logger = Logger.getLogger(XXEVulnerabilityDetector.class.getName());
    
    /**
     * The call graph object used by this tool
     */
    protected CallGraphObject cgo;
    
    /**
     * Holds a list of xxe vulnerabilities
     */
    protected List<ActualVulnerabilityItem> xxeVulnerabilities;

    /**
     * Creates an XXE Vulnerability Detector object
     * @param cgo the call graph object to use
     */
    public XXEVulnerabilityDetector(CallGraphObject cgo) {
        this.cgo = cgo;        
    }
    
    /**
     * Finds vulnerabilities. This methods searches the target java application and returns a list of actual 
     * vulnerabilities found
     * @return a list of actual vulnerabilities found
     */
    public List<ActualVulnerabilityItem> findVulnerabilities() {
        //if (true) {doTest(cgo); return null;}
        
        xxeVulnerabilities = new ArrayList<>();
        CallGraph cGraph = Scene.v().getCallGraph();
        MethodAnalysis mAnalysis = new MethodAnalysis(cgo, cGraph);
        
        Map<String, String> bugFindParametersMap = cgo.getBugFindParametersMap();
        String custRulesetLoc = bugFindParametersMap.get(OptionsParser.RULESET_OPT);
        
        List<VulnerabilityDefinitionItem> vulDefList = null;
        
        if (custRulesetLoc != null) {
            try {
                VulnerabilityDefinitionItems vdItems = XMLUtils.convertToPojo(new File(custRulesetLoc), VulnerabilityDefinitionItems.class);
                vulDefList = vdItems.getVulnerabilityDefinitionItems();
            } catch (JAXBException ex) {
                Logger.getLogger(XXEVulnerabilityDetector.class.getName()).log(Level.SEVERE, null, ex);
                System.exit(0);
            } catch (XMLStreamException ex) {
                Logger.getLogger(XXEVulnerabilityDetector.class.getName()).log(Level.SEVERE, null, ex);
                System.exit(0);
            } catch (FileNotFoundException ex) {
                Logger.getLogger(XXEVulnerabilityDetector.class.getName()).log(Level.SEVERE, null, ex);
                System.exit(0);
            }
        }
        else {
            vulDefList = VulnerableXMLMethodDefinitions.getVulnerableMethodDefinitionList();
        }
        
        
        //Documentb; classExists("com.sun.org.apache.xerces.internal.jaxp.DocumentBuilderImpl")
        for (VulnerabilityDefinitionItem vdi : vulDefList) { //cgo.getCallSites(cGraph, Scene.v().getSootClass("com.sun.org.apache.xerces.internal.jaxp.DocumentBuilderImpl").getMethodByName("fromInputStream"));//cgo.getMethodCallEdgesOutOfMethod(cGraph, Scene.v().getSootClass("play.libs.XML").getMethodByName("fromInputStream"));
            // if the class exists then it means the class is being used
            if (classExists(vdi.getMethodDefinition().getClassName())) {SootClass sc;// = Scene.v().gets
                //this.cgo.getMethodCallEdgesOutOfMethod(Scene.v().getCallGraph(), null)
                List<CallSite> listVulCS = this.cgo.getCallSites(cGraph, 
                        MethodDefinition.getSootMethod(Scene.v().getSootClass(vdi.getMethodDefinition().getClassName()), vdi.getMethodDefinition()));               
                List<VulnerabilityMitigationItem> listMitigationItems =  vdi.getMitigationList();
                
                if (listVulCS.isEmpty()) {// if there are no uses of the parser methods then continue
                    continue;
                }
                
                ActualVulnerabilityItem avi = new ActualVulnerabilityItem(vdi);
                avi.addVulnerabilityOccurrences(listVulCS);
                avi.setReason(vdi.getMitigationList().get(0).getSolutionDescription());
                this.xxeVulnerabilities.add(avi);
                                
                // for each vulnerable call site, try to check if the mitigation attempts to solve the problem
                for (CallSite csVul: listVulCS) {
                    //System.out.println(" possible application xxe vulnerability detected:\n" + cs);
                    
                    boolean isMitigated = false;
                    
                    SootMethod parentMethod = csVul.getEdge().src();
                    SootMethod vulMethod = csVul.getEdge().tgt();

                    // try to check if any of the mitigation attempts solves the problem 
                    // also check that the others are okay // later edit
                    // for now only immediate local mitigations are considered, static will be considered later
                    for (VulnerabilityMitigationItem vmi : listMitigationItems) {
                        if  (vmi.isGlobalMitigation() ) {
                            continue; // skip global for now;
                        }
                       
                        SootMethod solMeth = MethodDefinition.getSootMethod(Scene.v().getSootClass(vmi.getMethodDefinition().getClassName()),
                                vmi.getMethodDefinition()); 
                        
                        // continue (ie skip loop) if solMethod (mitigation attempt) isnt called in parent method
                        if (!mAnalysis.isCalledInMethod(parentMethod, solMeth)) {
                            // in this case check the definition of the factory method eg.
                            // DocumentBuilderFactorry secureDF = MyCustomDocumentBuiler.getSecureDocumentBuilder();
                            // DocumentBuidler dbuilder = secureDF.newDocumentBuilder();
                            // where the setFeature(...) might have already been set in getSecureDocumentBuilder() method
                            // and hence will not need to be called in the current method
                            
                            String solnClassType = vmi.getMethodDefinition().getClassName();

                            // first check if the setting should be applied on the xml parser itself or the the parser factory
                            boolean mitigationIsAppliedOnSameClass = solnClassType.equals(vdi.getMethodDefinition().getClassName());
                            if (!mitigationIsAppliedOnSameClass) {
                            // if the mitigation is not be applied on same object, ie to be on factory
                                // ensure that the factory is actually used to build the parser
                                boolean isAssigned = mAnalysis.isAssignedTo(parentMethod, solMeth.getDeclaringClass().getName(),
                                        vdi.getMethodDefinition().getClassName());
                                if (!isAssigned) {
                                    if (parentMethod.getDeclaringClass().isApplicationClass()) {
                                        logger.log(Level.WARNING, "The {0} object passed to {1} at line {2} in {3}", 
                                                new Object[]{solnClassType, vdi.getMethodDefinition().getClassName(), 
                                                    csVul.getLineLocation(), csVul.getSourceMethod()});
                                        //NSOT //throw new RuntimeException("no relationship between vulnerable method and mitigation setting");
                                        continue;
                                    }
                                }
                            }
                            
                            SimpleIntraDataFlowAnalysis sia = new SimpleIntraDataFlowAnalysis(parentMethod, 
                                    new ExceptionalUnitGraph(parentMethod.getActiveBody()));
                            Stmt targetStmt = csVul.getEdge().srcStmt();
                            JimpleLocal jl;                            
                            Value value = SimpleIntraDataFlowAnalysis.getInvokedLocal(targetStmt);
                            jl = (JimpleLocal) value;
                            List<Unit> lstDefPts = sia.getDefineLocations(jl, targetStmt);
                            
                            if (lstDefPts.isEmpty()) {// if it is empty, check if jl is a parameter
                                boolean isParameterLocal = SimpleIntraDataFlowAnalysis.isParameterLocal(parentMethod, jl);
                                
                                if (isParameterLocal) {// ie the parsing object or it's factory is passed in as an argument
                                    // in this case taint this method (ie parent method) as vulnerable and then repeat the
                                    throw new UnsupportedOperationException("not supported yet");
                                }
                                else {
                                    continue;
                                }
                            }
                            else {
                                Unit lastDef = lstDefPts.get(lstDefPts.size() - 1);
                                Stmt stmt = (Stmt) lastDef;
                                if (stmt.containsInvokeExpr()) {
                                    SootMethod sm = stmt.getInvokeExpr().getMethod();
                                    
                                    if (!sm.isAbstract()) {
                                        boolean isMitigationApplied = isMitigationApplied(sm, solnClassType, vmi, mAnalysis);

                                        if (isMitigationApplied) {
                                            avi.getOccurrencesList().remove(csVul);
                                            if (avi.getOccurrencesList().isEmpty()) {
                                                xxeVulnerabilities.remove(avi);
                                            }
                                            continue;
                                        }
                                    }
                                }
                            }                          
                            
                            continue;                            
                        }
                        
                        List<CallSite> listSolnCS = this.cgo.getCallSitesInMethod(cGraph, solMeth, parentMethod);                       
                        Collections.sort(listSolnCS);// sort according to line number occurrence (it is implemeneted in CallSite's comparable interface method)
                                                
                        // first check if the setting should be applied on the xml parser itself or the the parser factory
                        if (!solMeth.getDeclaringClass().getName().equals(vdi.getMethodDefinition().getClassName())) {
                            // if the mitigation is not be applied on same object, ie to be on factory
                            // ensure that the factory is actually used to build the parser
                            boolean isAssigned = mAnalysis.isAssignedTo(parentMethod, solMeth.getDeclaringClass().getName(), 
                                    vdi.getMethodDefinition().getClassName());
                            if (!isAssigned) {
                                throw new RuntimeException("no relationship between vulnerable method and mitigation setting");
                            }
                        }
                        
                        int order = mAnalysis.compare(parentMethod, solMeth, vulMethod);
                        // first check if fix is applied before xml parse method 
                        // next check if the correct settings have been applied
                        if (order == MethodAnalysis.CALLED_BEFORE) {// 
                            listSolnCS = mAnalysis.getAllCallsBefore(parentMethod, solMeth, csVul);//mAnalysis.getAllCallsBefore(parentMethod, solMeth, vulMethod, csVul.getEdge().srcStmt());
                            // now filter to get the last mitigation call that was applied
                            Variable v = (!solMeth.getDeclaringClass().getName().equals(vdi.getMethodDefinition().getClassName())) 
                                    ?                                    
                                    mAnalysis.getAssignerVariable(parentMethod, solMeth.getDeclaringClass().getName(), 
                                    vdi.getMethodDefinition().getClassName())
                                    :
                                    mAnalysis.getInvokedVariable(csVul.getEdge().srcStmt());
                            // filter by variable.(ie the variable that has a direct connection to the parser variable)
                            listSolnCS = mAnalysis.filterByVariable(listSolnCS, v);
                            
                            
                            Iterator<CallSite> iteCs = listSolnCS.iterator();
                            
                            boolean mitigationSet = false, mitigationCanceled = false, possibleMitigationIsCanceled = false;
                            while (iteCs.hasNext()) {
                                CallSite aCs = iteCs.next();
                                
                                int result = mAnalysis.compareArguments(aCs, vmi.getParameterValues());
                            
                                if (result == MethodAnalysis.SAME_ARGUMENT_VALUES) {
                                    mitigationSet = true; mitigationCanceled = false; possibleMitigationIsCanceled = false;
                                    //if (mAnalysis.isInvokedOnSameVariable(null, null))                                    
                                }
                                
                                if (mitigationSet) {
                                    // if there are more method calls of the mitigation, check that the rest are properly set
                                    // otherwise they may infact reverse the mitigation
                                    List<MitigationSpoiler> mitigationSpoilers = vmi.getMitigationSpoilers();                                    
                                    if (!mitigationSpoilers.isEmpty()) {
                                        while (iteCs.hasNext()) {
                                            CallSite nextCs = iteCs.next();
                                            for (MitigationSpoiler ms : mitigationSpoilers) {
                                                int tempResult = mAnalysis.compareArguments(nextCs, ms.getParameterValues());
                                                
                                                if (tempResult == MethodAnalysis.SAME_ARGUMENT_VALUES) {// ie mitigation spoiled/canceled
                                                    // we can only conclude that the mitigation is truely canceled if there is no any other callsie after this one
                                                    if (iteCs.hasNext()) {                                                        
                                                        mitigationCanceled = false;
                                                        possibleMitigationIsCanceled = true;
                                                    } else {
                                                        mitigationSet = false;
                                                        mitigationCanceled = true;
                                                        possibleMitigationIsCanceled = false;
                                                    }
                                                    break;
                                                }                                                
                                            }
                                            
                                            if (mitigationCanceled || possibleMitigationIsCanceled) {
                                                break;
                                            }
                                        }
                                    }
                                }

                                if (mitigationCanceled) {
                                    break;
                                }

                                if (!mitigationCanceled && !possibleMitigationIsCanceled && mitigationSet) {
                                    avi.getOccurrencesList().remove(csVul);
                                    if (avi.getOccurrencesList().isEmpty()) {
                                        xxeVulnerabilities.remove(avi);
                                    }
                                    break;
                                }

                                // this below is implied.
                                //if (possibleMitigationIsCanceled) {
                                //    continue;
                                //}
                            }                            
                            
//-------------------------
//                            int result = mAnalysis.compareArguments(listSolnCS.get(0), vmi.getParameterValues());
//                            
//                            if (result == MethodAnalysis.SAME_ARGUMENT_VALUES) {
//                                //if (mAnalysis.isInvokedOnSameVariable(null, null))
//                                avi.getOccurrencesList().remove(cs);
//                                if (avi.getOccurrencesList().isEmpty()) {
//                                    xxeVulnerabilities.remove(avi);
//                                }
//                                break;
//                            }
                        }

                    }

                    

                    
                }
            }
        }        
        
        return new ArrayList<>(xxeVulnerabilities);
        
    }
    
    /**
     * Checks if a class exists in the soot scene
     * @param className the name of the class to check
     * @return true if a class exists in the soot scene or false if otherwise
     */
    protected boolean classExists(String className) {
        return Scene.v().containsClass(className);
    }
   
    /**
     * Checks if mitigation is applied
     * @param parentMethod the parent method to check
     * @param objectClassName the class name of the object that holds the mitigation key
     * @param vmi the vulnerability mitigation item
     * @param mAnalysis the method analysis object to use
     * @return true if mitigation is applied or false of otherwise
     */
    protected boolean isMitigationApplied(SootMethod parentMethod, String objectClassName, VulnerabilityMitigationItem vmi, MethodAnalysis mAnalysis) {
        Body body = parentMethod.getActiveBody();
        Iterator<Local> ite = body.getLocals().iterator();
        List<Local> matchingLocals = new ArrayList<>();
        while (ite.hasNext()) {
            Local l = ite.next();
            if (l.getType().toString().equals(objectClassName)) {
                matchingLocals.add(l);
            }
        }
        
        if (matchingLocals.isEmpty()) return false;
        
        List<JReturnStmt> retStmtList = new ArrayList<>();
        
        Iterator<Unit> iteUnits = body.getUnits().iterator();
        
        while (iteUnits.hasNext()) {
            Unit u = iteUnits.next();
            if (u instanceof JReturnStmt) {
                retStmtList.add((JReturnStmt) u);
            }
        }
        
        if (retStmtList.isEmpty()) throw new RuntimeException("There should be at least a return statement in a method");
        
        SimpleIntraDataFlowAnalysis sia = new SimpleIntraDataFlowAnalysis(parentMethod, new ExceptionalUnitGraph(parentMethod.getActiveBody()));
        
        SootMethod solMeth = MethodDefinition.getSootMethod(Scene.v().getSootClass(vmi.getMethodDefinition().getClassName()),
                                vmi.getMethodDefinition()); 
        
        for (JReturnStmt retstmt : retStmtList) {
            Value val = ((ValueBox)retstmt.getUseBoxes().get(0)).getValue();
            
            List<CallSite> listSolnCS = mAnalysis.getAllCallsBefore(parentMethod, solMeth, retstmt);//mAnalysis.getAllCallsBefore(parentMethod, solMeth, vulMethod, csVul.getEdge().srcStmt());
            // now filter to get the last mitigation call that was applied
            Local locl = (Local) val;
            Variable v = new Variable(locl.getName(), locl.getType().toString(), Variable.LOCAL_VARIABLE);
            // filter by variable.(ie the variable that has a direct connection to the parser variable)
            listSolnCS = mAnalysis.filterByVariable(listSolnCS, v);

            Iterator<CallSite> iteCs = listSolnCS.iterator();

            boolean mitigationSet = false, mitigationCanceled = false, possibleMitigationIsCanceled = false;
            while (iteCs.hasNext()) {
                CallSite aCs = iteCs.next();

                int result = mAnalysis.compareArguments(aCs, vmi.getParameterValues());

                if (result == MethodAnalysis.SAME_ARGUMENT_VALUES) {
                    mitigationSet = true;
                    mitigationCanceled = false;
                    possibleMitigationIsCanceled = false;                    
                }

                if (mitigationSet) {
                    // if there are more method calls of the mitigation, check that the rest are properly set
                    // otherwise they may infact reverse the mitigation
                    List<MitigationSpoiler> mitigationSpoilers = vmi.getMitigationSpoilers();
                    if (!mitigationSpoilers.isEmpty()) {
                        while (iteCs.hasNext()) {
                            CallSite nextCs = iteCs.next();
                            for (MitigationSpoiler ms : mitigationSpoilers) {
                                int tempResult = mAnalysis.compareArguments(nextCs, ms.getParameterValues());

                                if (tempResult == MethodAnalysis.SAME_ARGUMENT_VALUES) {// ie mitigation spoiled/canceled
                                    // we can only conclude that the mitigation is truely canceled if there is no any other callsie after this one
                                    if (iteCs.hasNext()) {
                                        mitigationCanceled = false;
                                        possibleMitigationIsCanceled = true;
                                    } else {
                                        mitigationSet = false;
                                        mitigationCanceled = true;
                                        possibleMitigationIsCanceled = false;
                                    }
                                    break;
                                }
                            }

                            if (mitigationCanceled || possibleMitigationIsCanceled) {
                                break;
                            }
                        }
                    }
                }

                if (mitigationCanceled || (possibleMitigationIsCanceled && iteCs.hasNext())) {
                    return false;
                }
                
                if (!mitigationCanceled && !mitigationSet) {// check if it define point maybe it is secure
                    
                    Stmt targetStmt = retstmt;
                    JimpleLocal jl;
                    Value value = SimpleIntraDataFlowAnalysis.getInvokedLocal(targetStmt);
                    jl = (JimpleLocal) value;
                    List<Unit> lstDefPts = sia.getDefineLocations(jl, targetStmt);

                    if (lstDefPts.isEmpty()) {// if it is empty, check if jl is a parameter
                        return false;
                    } else {
                        Unit lastDef = lstDefPts.get(lstDefPts.size() - 1);
                        Stmt stmt = (Stmt) lastDef;
                        if (stmt.containsInvokeExpr()) {
                            SootMethod sm = stmt.getInvokeExpr().getMethod();

                            if (!sm.isAbstract()) {
                                boolean isMitigationApplied = isMitigationApplied(sm, objectClassName, vmi, mAnalysis);
                                if (!isMitigationApplied) return false;
                            }
                            else {
                                return false;
                            }
                        }
                    }
                }

                if (!mitigationCanceled && !possibleMitigationIsCanceled && mitigationSet) {
                    continue;
                }

                // this below is implied. // comment left intentionally
                //if (possibleMitigationIsCanceled) {
                //    continue;
                //}
            }
            
            if (!mitigationSet) return false;

        }

        return true;       
    }
}
