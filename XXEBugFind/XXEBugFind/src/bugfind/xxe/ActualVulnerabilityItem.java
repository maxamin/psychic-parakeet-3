/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

package bugfind.xxe;

import bugfind.sootadapters.CallSite;
import java.util.ArrayList;
import java.util.List;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlRootElement;

/**
 * This object represents an actual vulnerability
 * @author Mikosh
 */
@XmlRootElement
@XmlAccessorType (XmlAccessType.FIELD)
public class ActualVulnerabilityItem {
    @XmlElement (name = "VulnerabilityDefinitionItem")
    private VulnerabilityDefinitionItem vulnerabilityDefinitionItem;
    @XmlElement (namespace = "Occurrence")
    private List<CallSite> occurrencesList;
    @XmlElement (name = "Reason")
    private String reason;

    /**
     * Creates an ActualVulnerabilityItem
     */
    public ActualVulnerabilityItem() {
    }

    
    /**
     * Creates an actual vulnerability from the given vulnerability definition item
     * @param vulnerabilityDefinitionItem the item to create an actual vulnerablity from
     */
    public ActualVulnerabilityItem(VulnerabilityDefinitionItem vulnerabilityDefinitionItem) {
        this(vulnerabilityDefinitionItem, null, null);
    }
    
    /**
     * Creates an ActualVulnerabilityItem when given the vulnerabilityDefinitionItem, occurrences and reason
     * @param vulnerabilityDefinitionItem the definition of the vulnerability
     * @param occurrences the occurrences of the vulnerability
     * @param reason the reason it's an actual vulnerability
     */
    public ActualVulnerabilityItem(VulnerabilityDefinitionItem vulnerabilityDefinitionItem, List<CallSite> occurrences, String reason) {
        this.vulnerabilityDefinitionItem = vulnerabilityDefinitionItem;
        this.occurrencesList = (occurrences == null) ? new ArrayList<CallSite>() :occurrences;
        this.reason = reason;
    }

    /**
     * Gets the vulnerability definition for this object
     * @return the vulnerability definition for this object 
     */
    public VulnerabilityDefinitionItem getVulnerabilityDefinitionItem() {
        return vulnerabilityDefinitionItem;
    }

    /**
     * Gets a list corresponding to the occurrences of this actual vulnerability
     * @return  a list corresponding to the occurrences of this actual vulnerability
     */
    public List<CallSite> getOccurrencesList() {
        return occurrencesList;
    }    
    
    /**
     * Add a call site to the list of vulnerable locations
     * @param location the new call site location to be added
     * @return true if added or false other (* according to List.add(...))
     */
    public boolean addVulnerabilityOccurrence(CallSite location) {
        return getOccurrencesList().add(location);
    }
    
    /**
     * Adds all the occurrences occurring in the specified list to this object
     * @param listCallsites the list to add from
     */
    public void addVulnerabilityOccurrences(List<CallSite> listCallsites) {
        if (listCallsites != null) {
            for (CallSite cs : listCallsites) {
                occurrencesList.add(cs);
            }
        }
    }
    
    /**
     * Gets detail at the specified call site index
     * @param index the index of the call site in this object
     * @return  detail at the specified call site index
     */
    public String getCallSiteDetail(int index) {
        CallSite cs = getOccurrencesList().get(index);
        StringBuilder sb = new StringBuilder();
        
        sb.append("class: ").append(cs.getEdge().src().getDeclaringClass().getName()).append(" method: ")
                .append(cs.getEdge().src().getDeclaration()).append(" at line ").append(cs.getLineLocation())
                .append("\n");

        return sb.toString();
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append(this.vulnerabilityDefinitionItem.getMethodDefinition()).append(".");
        
        if (occurrencesList.size() >0) {
            sb.append("\n").append(occurrencesList.size()).append(" occurrence(s) at: \n");
        
            for (CallSite cs : occurrencesList) {
                sb.append("* class: ").append(cs.getEdge().src().getDeclaringClass().getName()).append(" method: ")
                        .append(cs.getEdge().src().getDeclaration()).append(" at line ").append(cs.getLineLocation())
                        .append("\n");
            }
            sb.deleteCharAt(sb.length()-1);
        }
        
        
                
        return sb.toString(); //To change body of generated methods, choose Tools | Templates.
    }

    /**
     * Sets the reason
     * @param reason the reason to be set
     */
    public void setReason(String reason) {
        this.reason = reason;
    }

    /**
     * Gets the reason for this actual vulnerability
     * @return the reason for this actual vulnerability 
     */
    public String getReason() {
        return reason;
    }
    
   
    
}
