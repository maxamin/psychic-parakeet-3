/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

package bugfind.xxe;

import bugfind.sootadapters.MethodDefinition;
import java.util.ArrayList;
import java.util.List;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlRootElement;

/**
 * This class represent a mitigation to a vulnerability. In simple terms, if there is a method that is 
 * vulnerable, then this should represent a method (including correct argument values) that if called should
 * before the XML parsing should prevent XXE attacks. A VulnerabilityMitigationItem has associated with it, 
 * a list of mitigation spoilers (i.e. incorrect combination of parameters/argument settings/values which if 
 * set can reverse a mitigation). See <code> MitigationSpoiler </code> for more info.
 * @see MitigationSpoiler
 * @author Mikosh
 */
@XmlRootElement
@XmlAccessorType (XmlAccessType.FIELD)
public class VulnerabilityMitigationItem {
    /**
     * Indicates a mitigation type of local
     */
    public static final String LOCAL = "LOCAL";
    /**
     * Indicates a mitigation type of factory
     */
    public static final String FACTORY = "FACTORY";
    /**
     * Indicates a mitigation type of global
     */
    public static final String GLOBAL = "GLOBAL";
    private MethodDefinition methodDefinition;
    @XmlElement (name = "ParameterValue")
    private List<MethodParameterValue> parameterValues;
    @XmlElement (name = "MitigationType")
    private String type;
    @XmlElement (name = "SolutionDescription")
    private String solutionDescription;
    @XmlElement (name = "MitigationSpoiler")
    private List<MitigationSpoiler> mitigationSpoilers;

    /**
     * Creates a new vulnerability mitigation item
     */
    public VulnerabilityMitigationItem() {}
    
    /**
     * Creates a VulnerabilityMitigationItem when given it's method definition/signature and a list of correct 
     * parameter values e.g <code> void javax.xml.parsers.SAXParser.setFeature("http://xml.org/sax/features/external-general-entities", false);
     * </code> is a mitigation setting we might try to describe using this constructor
     * @param methodDefinition the method definition
     * @param parameterValues the correct parameter values for the mitigation
     * @param type the type of the VulnerabilityMitigationItem. Acceptable values are VulnerabilityMitigationItem.LOCAL, FACTORY and GLOBAL
     */
    public VulnerabilityMitigationItem(MethodDefinition methodDefinition, List<MethodParameterValue> parameterValues, String type) {
        // first ensure the methoddefition and paramater values are compatible // 
        // make sure the parametervalue list is not null;
        parameterValues = (parameterValues == null) ? new ArrayList<MethodParameterValue>() : parameterValues;
        ensureParametersCompatibility(methodDefinition.getParameterList(), parameterValues);
        
        if (!type.equals(LOCAL) && !type.equals(FACTORY) && !type.equals(GLOBAL)) {
            throw new IllegalArgumentException("Invalid vulnerability mitigation type given");
        }
        
        this.methodDefinition = methodDefinition;
        this.parameterValues = parameterValues;
        this.type = type;
        
        this.mitigationSpoilers = new ArrayList<>();
    }
    
    private void ensureParametersCompatibility(List<MethodDefinition.MethodParameter> listMP, List<MethodParameterValue> listPV) {
        if (listMP.size() != listPV.size()) {
            throw new IllegalArgumentException("The number of parameter values should be equal to the number parameters "
                    + "expected by the method. Method expects " + listMP.size() + " but " + listPV.size() + " values were supplied.");            
        }
        for (int i=0; i< listMP.size(); ++i) {
            MethodDefinition.MethodParameter mp = listMP.get(i);
            MethodParameterValue pv = listPV.get(i);
            if (!mp.getType().equals(pv.getType())) {
                throw new RuntimeException("The method parameter type for argumemt " + (i+1) + " differs from the expected "
                        + "parameter value type (ie method parameter incompatible with value) See detail: MethodParameterType: " + 
                        mp.getType() + " != ParameterValueType: " + pv.getType());
            }
        }
        
        // may want to check valid values for primitive types
        
        // if method reaches here, it means there was no problem
    }

    /**
     * Get the method definition
     * @return the method definition 
     */
    public MethodDefinition getMethodDefinition() {
        return methodDefinition;
    }

    /**
     * Get the method parameter values
     * @return the method parameter values 
     */
    public List<MethodParameterValue> getParameterValues() {
        return parameterValues;
    }  

    /**
     * Get the type of mitigation
     * @return the type of mitigation 
     */
    public String getType() {
        return type;
    }

    /**
     * Set the type of mitigation
     * @param type the type of mitigation
     */
    public void setType(String type) {
        this.type = type;
    }
    
    /**
     * Returns true if mitigation type is local or false if otherwise
     * @return true if mitigation type is local or false if otherwise 
     */
    public boolean isLocalMitigation() {
        return (type.equals(VulnerabilityMitigationItem.LOCAL));
    }
    
    /**
     * Returns true if mitigation type is factory or false if otherwise
     * @return true if mitigation type is factory or false if otherwise 
     */
    public boolean isFactoryMitigation() {
        return (type.equals(VulnerabilityMitigationItem.FACTORY));
    }
    
    /**
     * Returns true if mitigation type is global or false if otherwise
     * @return true if mitigation type is global or false if otherwise 
     */
    public boolean isGlobalMitigation() {
        return (type == null ? VulnerabilityMitigationItem.GLOBAL == null : type.equals(VulnerabilityMitigationItem.GLOBAL));
    }

    /**
     * Gets the solution description
     * @return the solution description 
     */
    public String getSolutionDescription() {
        return solutionDescription;
    }

    /**
     * Sets the solution description
     * @param solutionDescription the solution description to be set 
     */
    public void setSolutionDescription(String solutionDescription) {
        this.solutionDescription = solutionDescription;
    }

    /**
     * Gets the mitigation spoilers list
     * @return the mitigation spoilers list
     */
    public List<MitigationSpoiler> getMitigationSpoilers() {
        return mitigationSpoilers;
    }
    
    /**
     * Add a mitigation spoiler
     * @param ms the mitigation spoiler to be added
     * @return true if added or false if otherwise (according to the return value of List.add(...))
     */
    public boolean addMitigationSpoiler(MitigationSpoiler ms) {
        return mitigationSpoilers.add(ms);
    }
    
    
    
    
}
