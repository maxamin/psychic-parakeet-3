package io.rivulet.internal.rerun.test;

import edu.columbia.cs.psl.phosphor.runtime.MultiTainter;
import edu.columbia.cs.psl.phosphor.runtime.Taint;
import io.rivulet.internal.RivuletAutoTaintWrapper;
import io.rivulet.internal.TaintedSinkValueSet;
import io.rivulet.internal.Violation;
import io.rivulet.internal.fuzz.generator.RerunGeneratorWrapper;
import io.rivulet.internal.rerun.TestRerunConfiguration;
import org.junit.Test;

import java.util.HashSet;
import java.util.LinkedList;

import static junit.framework.TestCase.assertEquals;
import static org.junit.Assert.assertTrue;

/* Checks that a generator produces critical-violation producing reruns. */
public abstract class GenerateRerunsBaseTest {

    // Auto-tainter instance used to check original run for violations
    private static final RivuletAutoTaintWrapper autoTainter = new RivuletAutoTaintWrapper();
    // Generator used to generate rerun builders and check String for critical violations
    private final RerunGeneratorWrapper generator;
    // A base sink target by the generator
    private final String baseSink;
    // Non-tainted portions of String being checked
    private final String template;
    // Non-malicious original tainted String put into the template
    private final String originalValue;
    // Sanitizers that may be used to mitigate attacks
    private final Sanitizer[] sanitizers;

    public GenerateRerunsBaseTest(RerunGeneratorWrapper generator, String template, String originalValue, Sanitizer... sanitizers) {
        this.generator = generator;
        this.template = template;
        this.originalValue = originalValue;
        this.baseSink = generator.getTargetedBaseSinks().get(0);
        this.sanitizers = sanitizers;
    }

    /* Passes the specified String to this instances generator and returns whether the generator determines that the
     * String demonstrated a critical violation only if critical is true.  */
    private boolean testString(String s, boolean critical) {
        // Have the generator check the String
        Violation violation = new Violation(baseSink, baseSink);
        generator.checkTaint(s, 0, violation);
        // Check if a critical violation would have been reported
        return critical == !violation.getTaintedValues().isEmpty();
    }

    /* Formats this instance's template with the specified original value to produce a String. Check that this instance's
     * generator does not report a critical violation for the produced String. Gathers the replacement values generated by
     * this instances's generator,checks that they are unique and each would cause the generator to report a critical
     * violation if used as a replacement for original value in the template. */
    @Test
    public void checkReplacementValues() {
        MultiTainter.taintedObject(this.originalValue, new Taint<>(ViolationTestUtils.SAMPLE_LABEL1));
        String original = String.format(template, originalValue);
        // Check that the original string would not produce a critical violation
        assertTrue(testString(original, false));
        // Get the violation that could be reported from an original test run
        Violation violation = new Violation(baseSink, baseSink);
        autoTainter.checkTaint(original, 0, violation);
        violation = TaintedSinkValueSet.processViolation(violation);
        // Gather replacement values
        LinkedList<String> replacementValues = new LinkedList<>();
        for(TestRerunConfiguration config : generator.generateReruns(violation, null, new Object[]{original})) {
            replacementValues.add(config.getReplacementValue(originalValue, ViolationTestUtils.SAMPLE_LABEL1));
        }
        // Check that replacement values are unique and that there are from 2 to 7 replacements values in total
        assertEquals(replacementValues.size(), (new HashSet<>(replacementValues).size()));
        assertTrue(replacementValues.size() >= 2 && replacementValues.size() <= 7);
        HashSet<String> successfulReplacementValues = new HashSet<>();
        // Check that at least one replacement succeeds when no sanitizer is used
        checkAtLeastOneReplacementSucceeds(replacementValues, template, null, successfulReplacementValues);
        for(Sanitizer sanitizer : sanitizers) {
            checkAtLeastOneReplacementSucceeds(replacementValues, template, sanitizer, successfulReplacementValues);
        }
        // Check that every replacement is successful for at least one sanitizer
        assertEquals(replacementValues.size(), successfulReplacementValues.size());
    }

    /* Checks that at least one of the specified replacement values creates a critical violation when used as a replacement
     * even when sanitized by the specified sanitizer. */
    private void checkAtLeastOneReplacementSucceeds(Iterable<String> replacementValues, String template, Sanitizer sanitizer,
                                                    HashSet<String> successfulReplacementValues) {
        int successfulReplacements = 0;
        for(String replacementValue : replacementValues) {
            String sanitizedReplacementValue = sanitizer == null ? replacementValue : sanitizer.sanitize(replacementValue);
            MultiTainter.taintedObject(sanitizedReplacementValue,  new Taint<>(ViolationTestUtils.SAMPLE_LABEL1));
            if(testString(String.format(template, sanitizedReplacementValue), true)) {
                successfulReplacements++;
                successfulReplacementValues.add(replacementValue);
            }
        }
        assertTrue(successfulReplacements > 0);
    }

    /* Represents some way of sanitizing input. */
    public interface Sanitizer {
        String sanitize(String input);
    }
}
